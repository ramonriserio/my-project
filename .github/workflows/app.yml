name: Docker Workflow

on:
  push:
    branches: [develop, main]
    paths:
      - 'src/**'
      - Dockerfile
      - '.github/workflows/app.yml'

  # Isso permite que o workflow de Terraform chame este arquivo ao finalizar com sucesso
  workflow_call:
    inputs:
      # Um flag para saber se devemos ignorar a checagem de infra (pois j√° veio do Terraform)
      skip_infra_check:
        required: false
        type: boolean
        default: true
    secrets:
      # Precisamos declarar que este workflow aceita esses segredos
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true
      EC2_USER:
        required: true
      EC2_SSH_KEY:
        required: true
        
permissions:
  contents: read
  id-token: write # Necess√°rio para AWS
  actions: read   # Necess√°rio para o filtro de paths

jobs:
  config:
    runs-on: ubuntu-24.04
    outputs:
      destroy: ${{ steps.read-destroy-config.outputs.destroy }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read destroy configuration
        id: read-destroy-config
        run: |
          DESTROY=$(jq -r ".${GITHUB_REF_NAME}" ./infra/destroy_config.json)
          echo "destroy=$DESTROY"
          echo "destroy=$DESTROY" >> $GITHUB_OUTPUT
  
  docker:
    runs-on: ubuntu-24.04
    needs: config
    if: ${{ needs.config.outputs.destroy != 'true' }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0    # O valor 0 baixa todo o hist√≥rico. 
                            # Garante que o comparador de paths tenha a refer√™ncia correta

      # --- L√ìGICA ANTI-DUPLICIDADE ---
      # Passo 1: Verifica o que mudou (APENAS se for push direto, e n√£o uma chamada via workflow_call)
      - name: Check if Infra modified
        if: github.event_name == 'push' && inputs.skip_infra_check != true
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
              - 'infra/**'
              - '.github/workflows/infra.yml'

      # Passo 2: Se for PUSH e a INFRA mudou, paramos aqui.
      - name: Cancel if Infra changed (Defer to Terraform Call)
        if: github.event_name == 'push' && steps.filter.outputs.infra == 'true'
        run: |
          echo "üõë Infraestrutura detectada nas mudan√ßas."
          echo "Abortando este job."
          echo "Motivo: O workflow de Terraform deve estar rodando e ir√° CHAMAR este workflow (via workflow_call) assim que terminar."
          exit 0

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24

      - name: Build Docker image
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/projeto-node-app:latest .

      - name: Login to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Push image to Docker Hub
        run: docker push ${{ secrets.DOCKER_USERNAME }}/projeto-node-app:latest

      - name: ‚úÖ Done
        run: echo "Image pushed to Docker Hub!"

      # Autenticar na AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::368453405930:role/projeto-node-ec2-vpc
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: us-east-1

      # Consultar a Infraestrutura (A M√°gica acontece aqui)
      - name: Get EC2 Public IP
        id: get_ip
        run: |
          # Se estiver na branch main, busca dev-projeto-node-ec2, sen√£o App-staging
          if [[ "${{ github.ref_name }}" == "main" ]]; then
             TARGET_NAME="prod-projeto-node-ec2"
          else
             TARGET_NAME="dev-projeto-node-ec2"
          fi
          echo "üîç Buscando IP das inst√¢ncias..."
          
          # Comando AWS CLI para filtrar inst√¢ncias:
          # - com respectivas tags
          # - que estejam no estado 'running' (evita pegar m√°quina parada)
          IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$TARGET_NAME" \
                      "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].PublicIpAddress" \
            --output text)

          # Valida√ß√£o de Seguran√ßa
          if [ -z "$IP" ]; then
            echo "‚ùå Erro: Nenhuma inst√¢ncia ativa encontrada com a tag 'correspondente."
            exit 1
          fi

          echo "‚úÖ IP Encontrado: $IP"
          
          # Exporta o IP para ser usado nos pr√≥ximos steps
          echo "public_ip=$IP" >> $GITHUB_OUTPUT

      - name: Deploy to EC2 via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.get_ip.outputs.public_ip }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "Conectado em: $(hostname -I)"
            echo "Branch atual: ${{ github.ref_name }}"
            echo "===== DOCKER DEPLOY ====="
            docker pull ${{ secrets.DOCKER_USERNAME }}/projeto-node-app:latest    # Baixa a imagem atualizada
            docker stop myapp || true && docker rm myapp || true                  # Remove container antigo se existir

            # PORTAS: 443 do host -> 3000 do container (SSL Nativo)
            # LOGS: Driver awslogs configurado
            docker run -d \
              --name myapp \
              --restart unless-stopped \
              -p 443:3000 \
              -v /home/ubuntu/server.crt:/usr/src/app/certs/server.crt \
              -v /home/ubuntu/server.key:/usr/src/app/certs/server.key \
              --log-driver awslogs \
              --log-opt awslogs-region=us-east-1 \
              --log-opt awslogs-group=/lacrei/app-logs-${{ github.ref_name }} \
              --log-opt awslogs-stream=app-instance-$(hostname) \
              ${{ secrets.DOCKER_USERNAME }}/projeto-node-app:latest

      - name: Smoke Test (Health Check)
        # S√≥ roda se o deploy SSH funcionou
        if: success() 
        run: |
          echo "üîç Verificando sa√∫de da aplica√ß√£o em https://${{ steps.get_ip.outputs.public_ip }}/status"
          
          # Tenta conectar 5 vezes, com intervalo de 10s entre tentativas
          # -k: Ignora erro de certificado autoassinado
          # -f: Falha o pipeline se o HTTP Code for erro (ex: 500, 404)
          # --retry: Tenta de novo se falhar
          curl -k -f --retry 5 --retry-delay 10 --connect-timeout 5 \
          https://${{ steps.get_ip.outputs.public_ip }}/status

          echo "‚úÖ Aplica√ß√£o respondeu com sucesso!"